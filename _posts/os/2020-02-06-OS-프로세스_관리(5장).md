---
layout: post
title: "프로세스 관리"
category: OS
tags: [OS]
comments: true
---

<br>

> '운영체제와 정보기술의 원리' 5장을 학습한 내용을 정리한 포스팅입니다

<br>

## 프로세스 관리

<br>

> **프로세스**

​	수행중인 프로그램을 뜻한다

<br>

> **프로세스 문맥 (process context)**

​	**프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보**. 시분할 시스템 환경에서 타이머 인터럽	트에 의해 짧은 시간 동안 CPU를 사용한 후 CPU를 선점당했다가 추후에 다시 CPU를 획득하는 식으로 CPU 관리가 이루어진	다. 따라서 CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면 지난 번 CPU 보유 시기에 어느 부분까지 명령을 수행했는	지 직전 수행 시점의 정확한 상태를 재현할 필요가 있다. 이때 필요한 정보가 프로세스 문맥이다 

<br>

> **프로세스 문맥 3요소**

- 하드웨어 문맥
  - 하드웨어 문맥은 CPU의 수행 상태를 나타내는 것으로 프로그램 카운터값과 각종 레지스터에 저장하고 있는 값
- 프로세스의 주소 공간
  - 코드, 데이터, 스택으로 구성됨
- 커널 상의 문맥
  - 프로세스를 관리하기 위한 PCB와 커널 스택

<br>

---

<br>

> **프로세스의 상태**
>
> 프로세스는 아래 사진 중 어느 한 상태에 머물러 있게 된다. 그리고 그 상태는 시간의 흐름에 따라 변하게 된다.
>
> 원래 수행중이던 프로세스를 준비 상태로 바꾸고 새로운 프로세스를 실행상태로 바꾸는 과정에서 `컨텍스트 스위칭`이 발생한다. 컨텍스트 스위칭은 원래 수행 중이던 프로세스의 문맥을 PCB에 저장하고 새로운 프로세스의 문맥을 PCB로부터 가져와세팅하는 과정을 의미한다. 하나의 프로세스에서 시스템 콜이나 인터럽트가 발생하면 CPU의 제어권이 운영체제에게로 넘어와 원래 실행 중이던 프로세스에서 커널의 코드가 실행된다. 이 경우에도 **CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PCB에 저장하게 되지만 이러한 과정을 컨텍스트 스위칭이라고 하지 않는다. 이는 하나의 프로세스가 사용자 모드에서 커널 모드로 실행 모드만 바뀌는 것일뿐 CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문이다. 이와 같은 모드 변경에 비해 문맥 교환에는 훨씬 많은 오버헤드가 뒤따르게 된다.**
>
> `Process A에서 인터럽트 또는 시스템콜 발생(사용자모드) -> 커널모드 -> Process A(사용자 모드)로 복귀 `
>
> ->  모드 변경
>
> `Process A에서 타이머 인터럽트 또는 I/O 요청 발생(사용자모드) -> 커널모드 -> Process B로 변경 `
>
> -> 컨텍스트 스위칭



> 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 `CPU 디스패치` 라고 한다. 



![Process-state.jpg](https://z-images.s3.amazonaws.com/d/d5/Process-state.jpg)

- 실행(running)
  - 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태
- 준비(ready)
  - 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
- 봉쇄(blocked, wait, sleep)
  - 프로세스에게 CPU를 주어도 당장 명령을 실행할 수 없는 상태
- 시작(new)
  - 프로세스가 생성중인 상태 (일시적)
  - 프로세스가 시작되어 그 프로세스를 위한 각종 자료 구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
- 완료(terminated)
  - 프로세스가 종료중인 상태 (일시적)
  - 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료 구조를 완전히 정리하지 못한 상태

<br>

> **입출력 과정**
>
> 입출력이 요청되면 `CPU를 반환한 다음 디스크 서비스를 기다리는 장치 큐에 가서 줄을 서게 되며 이때 프로세스의 상태는 봉쇄 상태가 된다.` 그리고 CPU는 즉시 실행할 수 있는 상태인 준비 큐에서 프로세스를 하나 선정해서 CPU를 할당한다. 입출력 작업이 끝나면 디스크 컨트롤러가 CPU에게 인터럽트를 발생시켜 입출력이 완료되었다는 것을 알린다. 그러면 CPU는 어떤 프로세스를 실행하고 있다가 인터럽트가 발생한 것을 확인하고 그에 대응하는 루틴을 실행한다. 루틴이 하는 일은 입출력이 완료된 프로세스를 장치 큐에서 빼내어 CPU를 기다리는 준비 큐에 넣고 프로세스의 상태를 준비상태로 바꾼 후 장치의 로컬 버퍼에 있는 내용을 메모리로 이동시키는 일련의 업무다.

<br>

---

<br>

> **프로세스 제어 블록(PCB)**

​	운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스당 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다.

<br>

> **PCB 구성요소**

![img](https://t1.daumcdn.net/cfile/tistory/2142EF505714CBD520)

- 프로세스의 상태
  - CPU를 할당해도 되는지 여부를 결정하기 위해 필요하다
- 프로그램 카운터 값
  - 다음에 수행할 명령의 위치를 가리킨다
- CPU 레지스터
  - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타낸다
- CPU 스케줄링 정보, 메모리 관리 정보
  - 각각 그 프로세스의 CPU 스케줄링과 메모리 할당을 위해 필요한 정보
- 자원 사용 정보
  - 사용자에게 자원 사용 요금을 계산해 청구하는 용도
- 입출력 상태 정보

<br>

---

<br>

> **프로세스를 스케줄링 하기위한 큐**

​	프로세스를 스케줄링 하기 위한 큐에는 작업 큐, 준비 큐, 장치 큐 등이 있다.

- 작업 큐
  - 시스템의 모든 프로세스를 관리하기 위한 큐로 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속하게 된다. 그러나 작업 큐에 있다고 해서 반드시 메모리를 가지고 있는 것은 아니다. 
- 준비 큐
  - 준비 큐는 CPU를 할당받고 실행되기 위해 기다리고 있는 프로세스의 집합을 말한다.
- 장치 큐
  - 각각의 장치마다 서비스를 기다리며 줄 서 있는 프로세스의 큐를 말한다.
  - 장치 큐에 속한 프로세스는 봉쇄 상태에 있게 된다



![img](https://qph.fs.quoracdn.net/main-qimg-6d28cba589f2975bad03f358d7eb84a7)

<br>

---

<br>



> **스케줄러**

​	어떤 프로세스에게 자원을 할당할지를 결졍하는 운영 체제 커널의 모듈

<br>

> **스케줄러의 종류**

- 장기 스케줄러

  - 작업 스케줄러라고도 부르며, 어떤 프로세스를 준비 큐에 삽입할지를 결정하는 역활을 한다. 
  - 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 속도가 느린 것이 허용된다
  - 현대 시분할 시스템에서 사용되는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분이다.
  - 현대 시분할 시스템에서는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어준다

- 중기 스케줄러

  - 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우를 해결하기 위한 스케줄러

  - 메모리에 적재된 프로세스의 수를 동적으로 조절한다.

  - 0순위 : blocked 된 프로세스를 스왑아웃 

  - 1순위 : 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑아웃

  - **중기 스케줄러의 등장으로 프로세스의 상태는 실행, 준비, 봉쇄 외에 중지(suspended, stopped)가 추가되었다**

    **(아래 사진 참고)** 

  - 중지 상태에 있는 프로세스는 외부에게 재개시키지 않는 이상 다시 활성화될 수 없으므로 메모리 자원이 당장 필요하지 않다. 따라서, 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃된다

  - 봉쇄 상태 -> 스왑 아웃 : suspended blocked, 준비 상태 -> 스왑 아웃 : suspended ready

- 단기 스케줄러

  - CPU 스케줄러라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지를 결정한다. 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다
  - 밀리 세컨드 이하의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 한다

![img](https://media.geeksforgeeks.org/wp-content/uploads/20190604122001/states_modified.png)

<br>

---

<br>

> **프로세스의 생성**

​	**시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 	복제 생성하게 된다**. 이때 프로세스를 생성한 프로세스를 부모 프로세스라고 하고 새롭게 생성된 프로세스를 자식 프로세스라고 	한다. 즉, 부모 프로세스가 자식 프로세스를 생성한다. **프로세스가 생성되면 자신만의 독자적인 주소 공간을 갖게 되며, 부모 프	로세스와 동일한 내용을 그대로 복사해서 생성한다. (PID를 제외하고 부모와 자식 프로세스 내용이 같음)**

<br>

> **프로세스 모델**

- 부모와 자식이 공존하며 수행되는 모델
  - 부모와 자식이 경쟁하는 관계
- 자식이 종료될 때까지 부모가 기다리는 모델
  - 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지않고 봉쇄 상태에 머물러 있다가 자식 프로세스가 종료되면 그 때 부모 프로세스가 준비 상태가 되어 다시 CPU를 얻을 권한이 생기게 된다
  - ex) DOS 커맨드창

<br>

> **프로세스 간의 협력**

​	**프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 다른 프로세스의 주소 공간을 참조하는 것은 원칙적으로는 	허용되지 않는다.** 하지만 프로세스들 간에 서로 협력할 때 효율적인 경우가 발생할 수 있다. 프로세스 간의 협력을 위해 운영체	제가 제공하는 대표적인 것으로는 IPC(Inter-Process Communication)이 있다.

<br>

>  **IPC**
>
> 하나의 컴퓨터 안에서 실행중인 서로 다른 프로세스 간의 발생하는 통신을 말한다.
>
> 의사소통 기능 + 동기화를 보장해주어야 한다

- 메시지 전달 방식
  - 프로세스 간의 **공유 변수를 일체 사용하지 않고** 메시지를 주고 받으면서 통신하는 방식
  - 두 프로세스의 주소 공간이 다르므로 커널의 시스템콜을 통해 통신한다
- 공유 메모리 방식
  - 커널의 시스템콜을 이용하여 주소 공간의 일부를 공유한다
  - 프로세스 A와 B가 주소공간을 독립적으로 가지고 있지만 이 주소 공간이 **물리적 메모리에 매핑될 때 공유 메모리 주소 영역에 대해서는 동일한 물리적 메모리로 매핑된다. 서로 간의 데이터 일관성 문제가 유발될 수 있으므로 동기화 문제를 고려해야 한다**

​	

![img](https://media.geeksforgeeks.org/wp-content/uploads/1-76.png)

ref. <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=1707071">운영체제와 정보기술의 원리</a><br>

ref. <a href="https://www.geeksforgeeks.org/states-of-a-process-in-operating-systems/">states of process</a><br>

ref. <a href="">IPC</a>

