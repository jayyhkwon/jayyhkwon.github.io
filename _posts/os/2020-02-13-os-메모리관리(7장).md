

## 메모리 관리

<br>

> **컴퓨터 시스템에서의 주소**

​	컴퓨터 시스템은 32비트의 주소 체계를 사용하고 있다. 따라서 2^32가지의 서로 다른 메모리 위치를 구분할 수 있다.

​	전국의 모든 위치를 숫자로만 구분하지 않고 행정 구역을 통해 '서울시 광진구 천호대로 120길 8' 식으로 계층적으로 나누어 관	리한다. 컴퓨터 상의 주소도 32비트를 그대로 사용하지 않고 효율적인 운영을 위해 연속된 일련의 영역을 행정 구역처럼 묶어서 	사용한다. 보통 4KB 단위로 묶어서 **페이지**라는 하나의 행정 구역을 만들게 된다.

<br>

> **주소 바인딩**

​	프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다. 이 주소를 **논리적 주소 또는 가	상 주소**라고 부른다. CPU는 이와 같이 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다. 논리적 주소는 	각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다. 반면, 물리적 주소는 물리적 메모리에 실제 올라가는 위치를 말한	다. 프로세스가 실행되기 위해서는 해당 프로그램이 물리적 메모리에 적재되어 있어야 하고 CPU가 기계어 명령을 수행하기 위	해 논리적 주소를 통해 메모리 참조를 하게 되면 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는 지를 확인해야 한	다. 이렇게 **프로세스의 눈리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩이라 한다**. 

<br>

> **주소 바인딩 방식**
>
> 프로그램이 적재되는 물리적 메모리의 주소가 언제 결정되느냐에 따라 세 가지로 분류할 수 있다

- **컴파일 타임 바인딩**

  - 컴파일 하는 시점에 해당 프로그램이 물리적 메모리의 어느 위치에 적재될 것인지 결정된다
  - 프로그램이 절대 주소로 적재된다는 뜻에서 `절대 코드를 생성하는 바인딩 방식 ` 이라고 말하기도 한다
  - 물리적 메모리 위치를 변경하려면 다시 컴파일 해야하는 수고가 필요하다

- **로드 타임 바인딩**

  - 프로그램이 실행될 때 물리적 메모리 주소가 결졍되는 방식

  - 로더의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때 까지 물리적 메모리 상의 위치가 고정된다

    > 로더란 사용자 프로그램을 메모리에 적재시키는 프로그램을 말한다

- **실행 시간 바인딩 (런타임 바인딩)**

  - 프로그램이 실행을 된 후에도 그 프로그램이 위치한 물리적 메모리 상의 주소가 변경될 수 있는 바인딩 방식

  - 이 방식에는 CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블을 사용하여 바인딩을 점검해야 한다

  - 다른 방식들과 달리 `기준 레지스터와 한계 레지스터, MMU(Memory Management Unit)`라는 하드웨어적인 자원이 뒷받침 되어야 한다

    > MMU
    >
    > 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

    ![8](https://www.cs.odu.edu/~cs471w/spring14/lectures/MainMemory_files/image010.jpg)

  

<br>

> **동적 로딩**

​	동적 로딩은 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위	해 사용하는 기법 중 하나이다. **동적 로딩에서는 프로세스가 시작 될 때 그 프로세스의 주소 공간 전체를 메모리에 다 올려 놓는 	것이 아니라 메모리를 좀 더 효율적으로 사용하기 위해 해당 루틴이 불려질 때 그 루틴만을 메모리에 적재하는 방식을 사용한다.** 	실제 프로그램의 상당 부분은 오류 처리 루틴과 같이 아주 특별한 경우에만 가끔씩 사용되는 방어용 코드다. 이런 코드까지 모두 	메모리에 올리는 경우 메모리 낭비가 초래된다.  프로그램 자체에서 구현이 가능하며 운영 체제가 라이브러리를 통해 지원 할 수	도 있다.

<br>

> **동적 연결**
>
> 연결이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적파일과 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행 파일을 생성하는 과정을 말한다.

​	 동적 연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법을 	말한다. 동적 연결과 대비되는 정적 연결에서는 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행 파일이 생	성된다. 따라서, 실행 파일의 크기가 상대적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므	로 물리적 메모리가 낭비되는 단점이 있다. 그에 비해 **동적 연결은 해당 라이브러리가 메모리에 이미 존재하는 지 살펴보고 존재	하는 경우 그 루틴으로 가서 메모리에서 직접 참조하고, 그렇지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적	재한 후 수행하게 된다.**

<br>

> **중첩**

​	프로세스의 주소 공간을 분할해 실제 필요한 부분만을 적재하는 기법을 말한다. 이러한 기법은 동적 로딩과 개념적으로 유사하 	다. 하지만 동적 로딩과 중첩을 사용하는 이유는 다르다**. 중첩은 하나의 프로그램의 크기에 비해 물리적 메모리가 작을 때 사용	하는 방법이고, 동적 로딩은 다중 프로세스를 동시에 올려놓고 효율적으로 메모리를 관리하기 위한 목적으로 사용된다.** 

<br>

> **스와핑**

​	**스와핑이란 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려 놓는 것을 말한다.** 스왑 영역	은 백킹 스토어라고도 부르며 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다. 파일 시스템은 전원이 나가더	라도 그 내용이 유지되어야 하는 비휘발성 저장 공간임에 비해 스왑 영역은 프로세스가 수행중인 동안에만 디스크에 일시적으로 	저장하는 공간이므로 저장 기간이 상대적으로 짧은 저장 공간이라고 할 수 있다. 작업의 방향에 따라 스왑 인(swap in), 스왑 아	웃(swap out)으로 나뉜다.

<br>

> **스와핑이 일어나는 과정**

​	스와퍼라고 불리는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정한다. 스와핑의 가장 중요한 역활은 메모리에 존재하는 	프로세스의 수를 조절할 수 있다는 점이다. 너무 많은 프로그램이 메모리에 동시에 올라오게 되면 프로세스당 할당되는 메모리	의 양이 지나치게 적어져 시스템 전체의 성능이 크게 떨어지게 된다. 스와핑은 이러한 문제를 해결하기 위해 몇몇 프로그램을 통	째로 디스크의 스왑 영역에 내쫒음으로써 메모리에 남아있는 프로그램들에게 필요한 메모리 공간을 보장한다.

![memory swapping](https://www.enterprisestorageforum.com/imagesvr_ce/3580/memory-swapping.jpeg)

<br>

> **물리적 메모리 할당방식**
>
> 물리적 메모리는 운영체제 영역과 사용자 프로세스 영역으로 나뉘어 사용된다
>
> 사용자 프로세스의 영역의 관리는 프로세스를 메모리에 올리는 방식에 따라 연속 할당 방식과 불연속 할당 방식으로 나뉜다

- **연속 할당 방식**
  - 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
  - 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다
  - **분할을 관리하는 방식에 따라 고정분할 방식과 가변분할 방식이 있다**

![contigous-memory-allocation](https://techdifferences.com/wp-content/uploads/2017/01/Contigous-memory-allocation.jpg)

- **불연속 할당 방식**

  - 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
  - 불연속 할당에는 각 프로세스의 주소공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재시키는 페이징 기법과 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그머늩로 나누어 세그먼트 단위로 적재하는 세그먼테이션 기법, 그리고 세그먼트하나를 다수의 페이지로 구성하는 페이지드 세그먼테이션 기법 등이 있다

  ![noncontigous-memory-allocation](https://techdifferences.com/wp-content/uploads/2017/01/Noncontigous-memory-allocation.jpg)



> **연속 할당 방식**

- **고정 분할 방식**

  - 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어 두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 한다
  - 분할의 크기를 모두 동일하게 할 수도 있고 다르게 할 수도 있다
  - 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있고 프로그램의 최대 크기 또한 제한된다
  - 외부조각, 내부조각이 발생할 수 있다

  > 외부조각
  >
  > 내부 조각으로 발생한 사용되지 않는 공간의 합
  >
  > 사진의 내부조각의 합은 4MB이므로 P5를 할당할 수 있는 크기이나 연속적이지 않으므로 할당할 수 없다

  > 내부조각
  >
  > 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간을 뜻한다. 하나의 분할 내부에서 사용되지 않는 메모리 조각을 말한다.

![os Fixed Partitioning](https://static.javatpoint.com/operating-system/images/os-fixed-partitioning.png)



- **가변 분할 방식**

  - 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식

  - **내부 조각은 발생하지 않으나,** 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 **외부조각이 발생할 가능성이 있다**

  - 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내의 가용공간 중 어느 위치에 올릴 것인지를 결정하는 것이 주요 쟁점 **(동적 메모리 할당 문제)**

    - 최초 적합 (first-fit) - 가장 먼저 찾아지는 곳에 프로세스를 할당한다 (시간효율적)
    - 최적 적합 (best-fit) - 가용 공간 중 가장 작은 가용 공간을 찾아 새로운 프로그램을 할당한다 (공간효율적)
    - 최악 적합 (worst-fit) - 가용 공간 중 가장 큰 공간에 새로운 프로그램을 할당한다

  - **외부 조각 문제를 해결하기 위해 컴팩션이라는 방법이 있다**

    > 컴팩션
    >
    > 물리적 메모리 중에서 프로세스에 의해 사용중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법. 비용이 많이 드는 작업이고 실행 도중에 프로세스의 주소가 동적으로 바뀔 수 있는 실행 시간 바인딩 방식에서만 수행될 수 있다.

<br>

> **불연속 할당 방식**

- **페이징 기법**

  - 프로세스의 주소 공간을 동일한 사이즈의 페이지 단위로 나누어 물리적 메모리에 불연속으로 저장하는 방식을 말한다

  - 페이징 기법에서는 각 프로세스 전체를 한꺼번에 물리적 메모리에 올릴 필요가 없으며 일부는 백킹 스토어에, 일부는 물리적 메모리에 혼재 시키는 것이 가능하다

  - 페이징 기법에서는 **물리적 메모리를 페이지 크기와 동일한 크기의 프레임으로 미리 나누어 둔다**

  - 특정 프로세스의 몇 번째 페이지가 물리적 메모리의 몇 번째 프레임에 들어 있다는 페이지별 주소 변환 정보를 유지하고 있어야 하므로 **모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블을 가지고 있으며, 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다**

  - **페이징 기법에서는 프로세스의 주소 공간과 물리적 메모리가 모두 같은 크기의 페이지 단위로 나누어지기 때문에 외부 조각 문제가 발생하지 않는다**. 그러나 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지는 내부 조각이 발생할 가능성이 있다

  - **Page table은 main memory에 존재하고 있다**

  -  Page-Table Base Register(PTBR) : Page table을 가리키는 포인터라고 할 수 있다.

  - Page-Table Length Register(PTLR) : Page table의 size를 나타낸다.

  - Main memory에 있는 Page Table에 접근하고 Data를 Physical Memory에 올리는 접근, 두번 접근을 해야 하기 때문에 성능이 떨어질 수 있다.

    > **Translation Look-aside Buffer(TLB)**
    >
    > **Register 사용 시 접근을 두번해야한다는 단점을 극복하기 위해 빠른 look up이 가능한 associative memory, TLB로 Hardware cache를 이용하는 방법이다.**
    >
    > Page Table을 검색하기 전에 Cahce에 있는 TLB를 먼저 확인함으로써 TLB에서 발견된다면 Main Memory에 존재하는 Page table을 검색하지 않고 한번의 look up으로 해결할 수 있다.
    >
    > TLB 중 일부는 address-space identifier(ASID)를 사용하여 고유한 process id를 저장하여 Protection을 한다.
    >
    > TLB는 Page Table의 일부를 저장한 것이기 때문에 TLB Hit가 높아질수록 성능이 좋아진다.

![img](https://t1.daumcdn.net/cfile/tistory/99696C335A000FD007)

<br>

> **계층적 페이징 기법**

- 현대의 컴퓨터는 주소 공간이 매우 큰 프로그램 지원
  - 32 bit 주소 사용시 : 2^32(4GB)의 주소 공간을 사용할 수 있다
  - page size가 4KB라 가정하면 1M개의 page table entry가 필요하다
  - 각 page entry가 4B이면 프로세스당 4MB의 page table이 필요하다 (1M * 4B = 4MB)
  - 그러나 대부분의 프로그램은 4GB의 주소공간 중 지극히 일부분만 사용하므로 page table 공간 낭비가 심하다
  - **page table 자체를 page로 구성**
  - 사용되지 않는 주소 공간에 대한 outer page table의 엔트리 값은 NULL

![img](https://t1.daumcdn.net/cfile/tistory/2641FE3C5757C75E01)

<br>

> 세그먼테이션

- 페이징 기법의 경우는 사용자 측면보다는 운영체제 측면에서 메모리를 관리한다. 예를 들어 함께 호출되는 함수를 페이징 기법을 이용할 경우 다른 페이지로 나눠져서 비효율적으로 메모리를 사용할 수 있다.
- 그에 비해 코드, 데이터, 스택 단위로 나누어 메모리를 좀 더 사용자 친화적으로 효율적으로 사용할 수 있다

![os Segmentation](https://static.javatpoint.com/operating-system/images/os-segmentation.png)



ref. <a href="https://www.cs.odu.edu/~cs471w/spring14/lectures/MainMemory.htm">Hardware Support for Relocation and Limit Registers</a><br>

ref. <a href="https://www.enterprisestorageforum.com/storage-hardware/memory-swapping.html">swapping </a>

ref. <a href="https://dongdd.tistory.com/66">paging</a>