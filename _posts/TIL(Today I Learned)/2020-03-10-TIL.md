---
layout: post
title:  " 20190310_TIL "
category: TIL (Today I Learned)
tags: [TIL]
comments: true
---



## C언어

#### puts(), printf()

- printf()와 달리 puts() 함수는 자동으로 개행('/n') 처리하여 줌



#### fgets()

- scanf()와 달리 개행문자('\n')도 포함하여 '\0'로 변환한 뒤 버퍼에 저장한다.

<br>

---

<br>

## TCP/IP 프로그래밍

####소켓과 파이프 

- 프로세스에 속하는 자원이 아니다. 운영체제의 자원이다.

<br>

####fork()

- 부모 프로세스를 통째로 복사한다
- 리턴 값을 통해 부모 프로세스인지, 자식프로세스 인지 확인할 수 있다 (0)

- 멀티 프로세서 네트워크 프로그래밍 할 때 fork() 유의점
  - 서버 프로세스를 fork()하면서 자식 프로세스는 서버 소켓 + 클라이언트 소켓 모두 가지게 된다
  - 이 경우 하나의 소켓에 두 개의 파일 디스크립터가 존재하게 되고, 하나의 디스크립터에서 소켓을 소멸해도 소멸되지않고 남아있게 된다

<br>

#### 좀비 프로세스

- 부모 프로세스에서 fork()하여 생성된 자식 프로세스가 종료되는 상황은 다음과 같다
  - 인자를 전달하면 exit를 호출하는 경우
  - main 함수에서 return문을 실행하면서 값을 반환하는 경우

- **종료되며 전달하는 값은 모두 운영체제로 전달되고 부모 프로세스에게 이 값이 전달될 때까지 자식 프로세스는 소멸되지 않는다** -> 부모프로세스가 책임지고 자식 프로세스가 전달하는 값을 처리해야 한다
  - **wait() 함수(blocking)**와 WIFEXITED, WEXITSTATUS 매크로 함수를 통해 자식 프로세스가 전달한 값을 처리한다
  - waitpid 함수(**인자에 따라 nonBlocking**)와 WIFEXITED, WEXITSTATUS 매크로 함수를 통해 자식 프로세스가 전달한 값을 처리한다

<br>

#### 시그널 핸들링

- waitpid() 함수를 사용하더라도 자식 프로세스가 종료됐는지 확인하려면 busy wait가 발생한다
- 특정 상황이 발생하면 운영체제가 부모 프로세스에게 알려주는 것이 더 효율적이다.
  - 특정상황
    - SIGALRM -  alarm 함수호출을 통해 등록된 시간이 된 상황
    - SIGINT - CTRL + C 가 입력된 상황
    - SIGHLD - 자식 프로세스가 종료된 상황
- 어떻게 ?
  - **signal (특정상황, 호출될 함수)**
    - 유닉스 계열 운영체제 별로 약간의 차이가 있을 수 있다
  - **sigaction(특정상황, 호출될 함수, 0)**
    - signal에 비해 안정적이다 -> 유닉스 계열 운영체제에 모두 호환된다





